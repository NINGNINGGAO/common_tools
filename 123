#include <bzlib.h>
#include <err.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <stdint.h>
#include <string.h>
/*
str:	A A B A B
index:  0 1 2 3 4
I: 	5 0 3 1 4 2
V: 	0 3 4 1 2 0
*/

#define MIN(a, b) (a) < (b) ? (a) : (b)

void print_arr(int64_t *arr, int64_t s, int64_t e) {
	for (int64_t i = s; i < e; i++) {
		printf("%ld\t", arr[i]);
	}
	printf("\n\n");
}

static void quickSort(int64_t *I, int64_t *V, int64_t start, int64_t len, int64_t h) {
	int64_t i, j, flag, num, tmp;
	for (i = start; i < start + len; i += num) {
		num = 1;
		flag = V[I[i] + h];
		for (j = 1; i + j < start + len; j++) {
			if (V[I[i + j] + h] < flag) {
				flag = V[I[i + j] + h];
				num = 0;
			}
			if (V[I[i + j] + h] == flag) {
				tmp = I[i + num];
				I[i + num] = I[i + j];
				I[i + j] = tmp;
				num++;
			}
		}
		for (j = 0; j < num; j++) V[I[i + j]] = i + num - 1;
		if (num == 1) I[i] = -1;
	}
}

static void doubly(int64_t *I, int64_t *V, const uint8_t *old, int64_t oldsize) {
	int64_t buckets[256];
	int64_t i, h, len;
	for (i = 0; i < 256; i++) buckets[i] = 0;
	for (i = 0; i < oldsize; i++) buckets[old[i]]++;
	for (i = 1; i < 256; i++) buckets[i] += buckets[i - 1];
	for (i = 255; i > 0; i--) buckets[i] = buckets[i - 1];
	buckets[0] = 0;

	for (i = 0; i < oldsize; i++) I[++buckets[old[i]]] = i;
	I[0] = oldsize;
	for (i = 0; i < oldsize; i++) V[i] = buckets[old[i]];
	V[oldsize] = 0;
	for (i = 1; i < 256; i++) if (buckets[i] == buckets[i - 1] - 1) I[buckets[i]] = -1;
	I[0] = -1;

	for (h = 1; I[0] != -(oldsize + 1); h += h) {
		len = 0;
		for (i = 0; i < oldsize + 1;) {
			if (I[i] < 0) {
				len -= I[i];
				i -= I[i];
			} else {
				if (len) I[i - len] = -len;
				len = V[I[i]] + 1 - i;
				quickSort(I, V, i, len, h);
				printf("I:\t");
				print_arr(I, 0, oldsize + 1);
				printf("V:\t");
				print_arr(V, 0, oldsize + 1);
				i += len;
				len = 0;
			}
		}
		if (len) I[i - len] = -len;
	}
	for (i = 0; i < oldsize + 1; i++) I[V[i]] = i;
	
}

void suffixArray(int64_t *I, int64_t *V, const uint8_t *old, int64_t oldsize) {
	doubly(I, V, old, oldsize);
}

static void offout(int64_t x, uint8_t *buf) {
	int64_t y;
	if (x < 0) y = -x;
	else y = x;

	buf[0] = y % 256; y -= buf[0];
	y /= 256; buf[1] = y % 256; y -= buf[1];	
	y /= 256; buf[2] = y % 256; y -= buf[2];
	y /= 256; buf[3] = y % 256; y -= buf[3];
	y /= 256; buf[4] = y % 256; y -= buf[4];
	y /= 256; buf[5] = y % 256; y -= buf[5];
	y /= 256; buf[6] = y % 256; y -= buf[6];
	y /= 256; buf[7] = y % 256;

	if (x < 0) buf[7] |= 0x80;
}

static int64_t matchlen(const uint8_t *old, int64_t oldsize, const uint8_t *new, int64_t newsize) {
	int64_t i;
	int64_t minLen = MIN(oldsize, newsize);
	for (i = 0; i < minLen; i++) {
		if (old[i] != new[i]) break;
	}
	return i;
}

static int64_t search(const int64_t *I, const uint8_t *old, int64_t oldsize, uint8_t *new, int64_t newsize,
		int64_t st, int64_t en, int64_t *pos) {
	int64_t x, y;

	if (en - st < 2) {
		x = matchlen(old + I[st], oldsize - I[st], new, newsize);
		y = matchlen(old + I[en], oldsize - I[en], new, newsize);
		if (x > y) {
			*pos = I[st];
			return x;
		} else {
			*pos = I[en];
			return y;
		}
	}
	x = st + (en - st) / 2;
	if (memcmp(old + I[x], new, MIN(oldsize - I[x], newsize)) < 0) {
		return search(I, old, oldsize, new, newsize, x, en, pos);
	} else {
		return search(I, old, oldsize, new, newsize, st, x, pos);
	}
}

static int bsdiff(const uint8_t *old, int64_t oldsize, const uint8_t *new, int64_t newsize) {
        int64_t *I,*V;
        int64_t scan,pos,len;
        int64_t lastscan,lastpos,lastoffset;
        int64_t oldscore,scsc;
        int64_t s,Sf,lenf,Sb,lenb;
        int64_t overlap,Ss,lens;
        int64_t i;
        uint8_t *buffer;
        uint8_t buf[8 * 3];
	
	FILE *fp;
	char path[] = "./agogin";
	fp = fopen(path, "aw");

        if((V=malloc((oldsize + 1) * sizeof(int64_t))) == NULL) return -1;
        I = malloc((oldsize + 1) * sizeof(int64_t));

        doubly(I, V, old, oldsize);
        free(V);
	
        buffer = malloc((newsize + 1) * sizeof(uint8_t));

        /* Compute the differences, writing ctrl as we go */
        scan=0;len=0;pos=0;
        lastscan=0;lastpos=0;lastoffset=0;
        while(scan < newsize) {
                oldscore=0;

                for(scsc=scan+=len;scan<newsize;scan++) {
                        len=search(I,old,oldsize,new+scan,newsize-scan,
                                        0,oldsize,&pos);

                        for(;scsc<scan+len;scsc++)
                        if((scsc+lastoffset<oldsize) &&
                                (old[scsc+lastoffset] == new[scsc]))
                                oldscore++;

                        if(((len==oldscore) && (len!=0)) ||
                                (len>oldscore+8)) break;

                        if((scan+lastoffset<oldsize) &&
                                (old[scan+lastoffset] == new[scan]))
                                oldscore--;
                };

                if((len!=oldscore) || (scan==newsize)) {
                        s=0;Sf=0;lenf=0;
                        for(i=0;(lastscan+i<scan)&&(lastpos+i<oldsize);) {
                                if(old[lastpos+i]==new[lastscan+i]) s++;
                                i++;
                                if(s*2-i>Sf*2-lenf) { Sf=s; lenf=i; };
                        };

                        lenb=0;
                        if(scan<newsize) {
                                s=0;Sb=0;
                                for(i=1;(scan>=lastscan+i)&&(pos>=i);i++) {
                                        if(old[pos-i]==new[scan-i]) s++;
                                        if(s*2-i>Sb*2-lenb) { Sb=s; lenb=i; };
                                };
                        };

                        if(lastscan+lenf>scan-lenb) {
                                overlap=(lastscan+lenf)-(scan-lenb);
                                s=0;Ss=0;lens=0;
                                for(i=0;i<overlap;i++) {
                                        if(new[lastscan+lenf-overlap+i]==
                                           old[lastpos+lenf-overlap+i]) s++;
                                        if(new[scan-lenb+i]==
                                           old[pos-lenb+i]) s--;
                                        if(s>Ss) { Ss=s; lens=i+1; };
                                };

                                lenf+=lens-overlap;
                                lenb-=lens;
                        };

                        offout(lenf,buf);
                        offout((scan-lenb)-(lastscan+lenf),buf+8);
                        offout((pos-lenb)-(lastpos+lenf),buf+16);

                        /* Write control data */
                        if (fwrite(buf, sizeof(uint8_t), 24, fp))
                                return -1;

                        /* Write diff data */
                        for(i=0;i<lenf;i++)
                                buffer[i]=new[lastscan+i]-old[lastpos+i];
                        if (fwrite(buffer, sizeof(uint8_t), lenf, fp))
                                return -1;

                        /* Write extra data */
                        for(i=0;i<(scan-lenb)-(lastscan+lenf);i++)
                                buffer[i]=new[lastscan+lenf+i];
                        if (fwrite(buffer, sizeof(uint8_t), (scan-lenb)-(lastscan+lenf), fp))
                                return -1;
		
			char str[] = "19951101";
			fwrite(str, sizeof(uint8_t), 8, fp);

                        lastscan=scan-lenb;
                        lastpos=pos-lenb;
                        lastoffset=pos-scan;
                };
        };
	fclose(fp);
        return 0;
}


int main() {
	char old[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ";
	int64_t oldsize = strlen(old);
	char new[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ19951101ABCDEFGHIJKLMNOPQRSTUVWXYZ";
	int64_t newsize = strlen(new);
	bsdiff(old, oldsize, new, newsize);
	return 0;
}
